= Driver architecture
:toc: left
include::../common/homelink.adoc[]

The system uses a service-based approach to drivers. The following components
take their part in this:

* *devicemanager* is the central device registry
** *libdevice* is the interface library for devicemanager

* *pcidriver* is the PCI driver
** *libpci* is the interface library for pcidriver

* *ps2driver* is a driver for PS/2 mouse & keyboard input
** *libps2* is the PS/2 implementation
** *libps2driver* is the interface library for ps2driver

* *ahcidriver* is the SATA/AHCI implementation
** *libahci* is the interface library for ahcidriver

* *efifbdriver* is the EFI framebuffer video graphics driver
* *vmsvgadriver* is the VMSVGA video graphics driver
* *libvideo* is a generic interface library for video drivers


An _interface library_ contains functions used to interact with the driver and
usually also the purpose-related headers.


== Basic initialization

The *devicemanager* first interacts with pcidriver to enumerate PCI devices and
then, based on available devices, starts up further driver processes.

=== Graphics

Depending on the available devices, one of the available video drivers is
started. All video drivers implement the video driver interface defined in
*libvideo*.

The video mode can then be initialized by using _videoDriverSetMode_, which
is usually done by the *windowserver*.

=== Filesystem

For drives and file systems, the implementation is not finalized but the plan is to have:

* *fsdiscovery* a driver that checks for filesystems on block devices
    that any driver (like ahcidriver) has registered
* *libblockdevicedriver* a generic interfacing library for all drivers that
    implement block devices; must be implemented by ahcidriver
* *fatdriver* a FAT filesystem driver

The idea is that *fsdiscovery* will wait for block devices being registered;
if a new device apperas, it will use *libblockdevicedriver* to call *ahcidriver*
to read the first sector of the drive. Then it will identify what filesystem is
on that drive and run the respective driver.

For the FAT example, it will start *fatdriver* and tell it the device ID of the
drive. The driver then again uses *libblockdevicedriver* to interact with
*ahcidriver* to actually read/write data on the drive.
